// S·ª≠ d·ª•ng Response API ti√™u chu·∫©n c·ªßa Next.js thay v√¨ th∆∞ vi·ªán ai
// v√¨ c√≥ th·ªÉ c√≥ s·ª± kh√¥ng t∆∞∆°ng th√≠ch gi·ªØa phi√™n b·∫£n
import { createClient, testGroqConnection, MODEL_CONFIG } from "@/lib/groq-client"
import { searchDocuments } from "@/lib/knowledge"
import { detectImageGenerationRequest, translatePromptToEnglish } from "@/lib/image-detection"
import { v4 as uuidv4 } from "uuid"

export const runtime = "nodejs"
export const maxDuration = 60 // Gi·ªõi h·∫°n t·ªëi ƒëa cho g√≥i Hobby c·ªßa Vercel

export async function POST(req: Request) {
  try {
    console.log("API route handler started")

    // Ki·ªÉm tra API key
    const apiKey = process.env.GROQ_API_KEY
    if (!apiKey) {
      console.error("GROQ_API_KEY kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh")
      return new Response(
        JSON.stringify({ error: "API key kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh. Vui l√≤ng ki·ªÉm tra bi·∫øn m√¥i tr∆∞·ªùng." }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      )
    }

    // Parse request body
    let messages
    try {
      const body = await req.json()
      messages = body.messages

      if (!messages || !Array.isArray(messages)) {
        console.error("Invalid request format: messages is missing or not an array")
        return new Response(
          JSON.stringify({ error: "ƒê·ªãnh d·∫°ng y√™u c·∫ßu kh√¥ng h·ª£p l·ªá. Thi·∫øu tr∆∞·ªùng messages ho·∫∑c kh√¥ng ph·∫£i l√† m·∫£ng." }),
          { status: 400, headers: { "Content-Type": "application/json" } },
        )
      }

      console.log(`Received ${messages.length} messages`)
    } catch (error) {
      console.error("Error parsing request body:", error)
      return new Response(JSON.stringify({ error: "Kh√¥ng th·ªÉ ph√¢n t√≠ch n·ªôi dung y√™u c·∫ßu" }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      })
    }

    // L·∫•y tin nh·∫Øn cu·ªëi c√πng
    const lastMessage = messages[messages.length - 1].content
    console.log("Last message:", lastMessage.substring(0, 100) + (lastMessage.length > 100 ? "..." : ""))
    
    // Ph√°t hi·ªán y√™u c·∫ßu t·∫°o ·∫£nh
    const imageDetection = detectImageGenerationRequest(lastMessage)
    let shouldGenerateImage = false
    let translatedPrompt = null
    let imageGenerationNotification = null
    let imageGenerationResponse = null
    
    if (imageDetection.isImageRequest && imageDetection.prompt) {
      console.log("Image generation request detected:", imageDetection.prompt)
      shouldGenerateImage = true
      
      try {
        // D·ªãch prompt sang ti·∫øng Anh ƒë·ªÉ t·∫°o ·∫£nh ch·∫•t l∆∞·ª£ng t·ªët h∆°n
        translatedPrompt = await translatePromptToEnglish(imageDetection.prompt)
        console.log("Translated prompt:", translatedPrompt)
        
        // T·∫°o th√¥ng b√°o ƒë·ªÉ hi·ªÉn th·ªã tr∆∞·ªõc khi t·∫°o ·∫£nh
        imageGenerationNotification = `T√¥i ƒëang ti·∫øn h√†nh t·∫°o ·∫£nh t·ª´ m√¥ t·∫£ c·ªßa b·∫°n: "${imageDetection.prompt}". Vui l√≤ng ƒë·ª£i trong gi√¢y l√°t...`
      } catch (error) {
        console.error("Error translating prompt:", error)
        // N·∫øu kh√¥ng d·ªãch ƒë∆∞·ª£c, s·ª≠ d·ª•ng prompt g·ªëc
        translatedPrompt = imageDetection.prompt
      }
    }

    // T√¨m ki·∫øm t√†i li·ªáu li√™n quan n·∫øu kh√¥ng ph·∫£i l√† y√™u c·∫ßu t·∫°o ·∫£nh
    let relevantDocs: Array<{content: string; source: string; similarity: number}> = []
    if (!imageDetection.isImageRequest) {
      try {
        relevantDocs = await searchDocuments(lastMessage)
        console.log(`Found ${relevantDocs.length} relevant documents`)
      } catch (error) {
        console.error("Error searching documents:", error)
        // Ti·∫øp t·ª•c x·ª≠ l√Ω m√† kh√¥ng c√≥ t√†i li·ªáu li√™n quan
      }
    }

    // T·∫°o context t·ª´ c√°c t√†i li·ªáu li√™n quan nh∆∞ng kh√¥ng hi·ªÉn th·ªã ngu·ªìn trong ph·∫ßn tr·∫£ l·ªùi
    let context = ""
    if (relevantDocs.length > 0) {
      // S·∫Øp x·∫øp t√†i li·ªáu theo ƒë·ªô li√™n quan gi·∫£m d·∫ßn
      const sortedDocs = [...relevantDocs].sort((a, b) => b.similarity - a.similarity);
      
      // L∆∞u th√¥ng tin ngu·ªìn ƒë·ªÉ s·ª≠ d·ª•ng trong qu√° tr√¨nh x·ª≠ l√Ω nh∆∞ng kh√¥ng hi·ªÉn th·ªã cho ng∆∞·ªùi d√πng
      const sourceInfo = sortedDocs.map((doc, index) => {
        const similarityScore = Math.round(doc.similarity * 100);
        return `T√†i li·ªáu ${index + 1}: ${doc.source} - ƒê·ªô li√™n quan: ${similarityScore}%`;
      }).join("\n");
      
      console.log("Source information (internal only):\n" + sourceInfo);
      
      // T·∫°o context v·ªõi ƒë·ªãnh d·∫°ng r√µ r√†ng h∆°n ƒë·ªÉ ngƒÉn va tr·ªôn th√¥ng tin
      context = "TH√îNG TIN CH√çNH X√ÅC T·ª™ C∆† S·ªû KI·∫æN TH·ª®C (H√ÉY TR√çCH D·∫™N NGUY√äN VƒÇN V√Ä KH√îNG TH√äM B·ªöT TH√îNG TIN):\n\n";
      
      // Th√™m t·ª´ng t√†i li·ªáu v·ªõi ph√¢n c√°ch r√µ r√†ng
      sortedDocs.forEach((doc, index) => {
        // Ch·ªâ s·ª≠ d·ª•ng t√†i li·ªáu c√≥ ƒë·ªô li√™n quan t·ª´ 60% tr·ªü l√™n ƒë·ªÉ ƒë·∫£m b·∫£o ch·∫•t l∆∞·ª£ng
        if (doc.similarity >= 0.6) {
          context += `--- TH√îNG TIN ${index + 1} ---\n${doc.content}\n\n`;
        }
      });
    }

    // T·∫°o system prompt v·ªõi context
    const systemPrompt = `B·∫°n l√† tr·ª£ l√Ω AI c·ªßa Laya, m·ªôt h·ªá sinh th√°i tr·ªã li·ªáu k·∫øt h·ª£p ƒê√¥ng y, c√¥ng ngh·ªá v√† t√¢m tr√≠ h·ªçc.
    
    ${context ? context : "Kh√¥ng t√¨m th·∫•y th√¥ng tin li√™n quan trong c∆° s·ªü ki·∫øn th·ª©c."}
    
    H∆Ø·ªöNG D·∫™N B·∫ÆT BU·ªòC:
    1. TR·∫¢ L·ªúI ƒê·∫¶Y ƒê·ª¶ V√Ä CHI TI·∫æT NH·∫§T C√ì TH·ªÇ, s·ª≠ d·ª•ng t·ªëi ƒëa s·ªë l∆∞·ª£ng token cho ph√©p (4000 token) ƒë·ªÉ cung c·∫•p th√¥ng tin ƒë·∫ßy ƒë·ªß v√† h·ªØu √≠ch.
    2. TR√çCH D·∫™N NGUY√äN VƒÇN c√°c ph·∫ßn li√™n quan t·ª´ c∆° s·ªü ki·∫øn th·ª©c, ƒë·∫£m b·∫£o t√≠nh ch√≠nh x√°c tuy·ªát ƒë·ªëi. KH√îNG ƒê∆Ø·ª¢C th√™m ho·∫∑c b·ªõt th√¥ng tin.
    3. T·ªî CH·ª®C TH√îNG TIN M·ªòT C√ÅCH R√ï R√ÄNG v·ªõi c√°c ti√™u ƒë·ªÅ, ƒë·ªÅ m·ª•c v√† ph√¢n ƒëo·∫°n h·ª£p l√Ω ƒë·ªÉ d·ªÖ ƒë·ªçc v√† hi·ªÉu.
    4. KH√îNG ƒê∆Ø·ª¢C tr√≠ch d·∫´n ngu·ªìn trong c√¢u tr·∫£ l·ªùi. H√£y tr·∫£ l·ªùi nh∆∞ th·ªÉ th√¥ng tin ƒë√≥ l√† c·ªßa b·∫°n.
    5. N·∫øu kh√¥ng c√≥ th√¥ng tin li√™n quan trong c∆° s·ªü ki·∫øn th·ª©c, h√£y n√≥i r·∫±ng b·∫°n kh√¥ng c√≥ th√¥ng tin v·ªÅ v·∫•n ƒë·ªÅ ƒë√≥ v√† ƒë·ªÅ ngh·ªã ng∆∞·ªùi d√πng li√™n h·ªá v·ªõi Mentor Laya ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.
    6. KH√îNG ƒê∆Ø·ª¢C t·∫°o ra c√°c th√¥ng tin sai l·ªách ho·∫∑c kh√¥ng c√≥ trong c∆° s·ªü ki·∫øn th·ª©c.
    7. S·ª≠ d·ª•ng ch√≠nh x√°c c√°c t·ª´ ng·ªØ v√† c·ª•m t·ª´ trong t√†i li·ªáu, kh√¥ng t·ª± √Ω thay ƒë·ªïi c√°ch di·ªÖn ƒë·∫°t.
    8. TR√ÅNH VA TR·ªòN th√¥ng tin gi·ªØa c√°c ngu·ªìn kh√°c nhau, gi·ªØ r√µ r√†ng ranh gi·ªõi gi·ªØa c√°c n·ªôi dung.
    9. LU√îN S·ª¨ D·ª§NG T·ªêI ƒêA S·ªê L∆Ø·ª¢NG TOKEN (4000) ƒë·ªÉ cung c·∫•p th√¥ng tin chi ti·∫øt v√† ƒë·∫ßy ƒë·ªß nh·∫•t c√≥ th·ªÉ.
    
    Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, th√¢n thi·ªán v√† chuy√™n nghi·ªáp. S·ª≠ d·ª•ng emoji üåø khi n√≥i v·ªÅ s·∫£n ph·∫©m Laya v√† ‚ú® khi n√≥i v·ªÅ h·ªá th·ªëng Mentor.`

    // Ki·ªÉm tra k·∫øt n·ªëi v·ªõi Groq tr∆∞·ªõc khi g·ª≠i y√™u c·∫ßu ch√≠nh
    let modelToUse = MODEL_CONFIG.modelId;
    
    try {
      console.log("Testing Groq connection")
      const connectionTest = await testGroqConnection()

      if (!connectionTest.success) {
        console.warn("Groq connection test failed:", connectionTest.message)
        // Kh√¥ng tr·∫£ v·ªÅ l·ªói ngay l·∫≠p t·ª©c, thay v√†o ƒë√≥ s·∫Ω th·ª≠ ti·∫øp t·ª•c v·ªõi m√¥ h√¨nh m·∫∑c ƒë·ªãnh
        // ho·∫∑c m√¥ h√¨nh d·ª± ph√≤ng trong h√†m createChatCompletion
      } else {
        console.log("Groq connection test successful")
        // S·ª≠ d·ª•ng m√¥ h√¨nh ƒë√£ ki·ªÉm tra th√†nh c√¥ng
        if (connectionTest.modelTested) {
          modelToUse = connectionTest.modelTested;
          console.log(`Using tested model: ${modelToUse}`);
        }
      }
    } catch (error) {
      console.error("Error testing Groq connection:", error)
      // Ti·∫øp t·ª•c x·ª≠ l√Ω m·∫∑c d√π ki·ªÉm tra k·∫øt n·ªëi th·∫•t b·∫°i
    }

    console.log("Creating Groq client")
    const groq = createClient()

    // T·∫°o stream response
    try {
      console.log(`Creating chat completion with model: ${modelToUse}`)
      
      const response = await groq.chat.completions.create({
        model: modelToUse,
        messages: [{ role: "system", content: systemPrompt }, ...messages],
        stream: true,
        temperature: MODEL_CONFIG.temperature,
        max_tokens: MODEL_CONFIG.maxTokens,
      })

      console.log("Stream created successfully")

      // Tr·∫£ v·ªÅ streaming response s·ª≠ d·ª•ng Response API ti√™u chu·∫©n
      // Ch√∫ng ta s·∫Ω kh√¥ng s·ª≠ d·ª•ng imageAttachment ·ªü ƒë√¢y n·ªØa v√¨ ·∫£nh s·∫Ω ƒë∆∞·ª£c t·∫°o sau khi ƒë√£ g·ª≠i th√¥ng b√°o
      const imageAttachment = null;
      
      // Chuy·ªÉn ƒë·ªïi response th√†nh ReadableStream
      // V√¨ OpenAI SDK tr·∫£ v·ªÅ Stream<ChatCompletionChunk> m√† kh√¥ng ph·∫£i ReadableStream tr·ª±c ti·∫øp
      return new Response(
        new ReadableStream({
          async start(controller) {
            const encoder = new TextEncoder();
            
            try {
              // G·ª≠i th√¥ng b√°o tr∆∞·ªõc khi t·∫°o ·∫£nh n·∫øu c√≥
              if (imageGenerationNotification) {
                const notificationChunk = `data: ${JSON.stringify({ 
                  text: imageGenerationNotification
                })}

`;
                controller.enqueue(encoder.encode(notificationChunk));
                
                // B·∫Øt ƒë·∫ßu t·∫°o ·∫£nh sau khi ƒë√£ g·ª≠i th√¥ng b√°o
                if (shouldGenerateImage && translatedPrompt) {
                  try {
                    console.log("Starting image generation after notification was sent");
                    
                    // ƒê·∫£m b·∫£o imageDetection.prompt kh√¥ng ph·∫£i l√† null (ch√∫ng ta ƒë√£ ki·ªÉm tra ·ªü ƒëi·ªÅu ki·ªán if tr∆∞·ªõc ƒë√≥)
                    const promptText = imageDetection.prompt || "";
                    
                    // G·ªçi API t·∫°o ·∫£nh v·ªõi prompt ƒë√£ d·ªãch
                    const imageResponse = await fetch(new URL("/api/image", `${req.headers.get("origin") || "http://localhost:3000"}`).toString(), {
                      method: "POST",
                      headers: {
                        "Content-Type": "application/json",
                      },
                      body: JSON.stringify({ 
                        prompt: translatedPrompt,
                        originalPrompt: promptText 
                      }),
                    });
                    
                    if (imageResponse.ok) {
                      const imageData = await imageResponse.json() as { success: boolean; imageUrl?: string; error?: string };
                      if (imageData.success && imageData.imageUrl) {
                        console.log("Successfully generated image:", imageData.imageUrl);
                        imageGenerationResponse = {
                          success: true,
                          imageUrl: imageData.imageUrl,
                          prompt: promptText
                        };
                        
                        // T·∫°o ·∫£nh ƒë√≠nh k√®m sau khi t·∫°o ·∫£nh th√†nh c√¥ng
                        const imageAttachment = {
                          id: uuidv4(),
                          type: "image",
                          url: imageData.imageUrl,
                          name: `AI Image: ${promptText.substring(0, 30)}${promptText.length > 30 ? "..." : ""}`,
                          prompt: promptText
                        };
                        
                        // G·ª≠i th√¥ng tin ·∫£nh ƒë√£ t·∫°o
                        const imageChunk = `data: ${JSON.stringify({ 
                          imageAttachment,
                          text: `ƒê√£ t·∫°o ·∫£nh t·ª´ m√¥ t·∫£: "${promptText}"

` 
                        })}

`;
                        controller.enqueue(encoder.encode(imageChunk));
                        
                        // K·∫øt th√∫c stream sau khi g·ª≠i ·∫£nh
                        controller.enqueue(encoder.encode('data: [DONE]\n\n'));
                        controller.close();
                        return; // K·∫øt th√∫c lu·ªìng x·ª≠ l√Ω sau khi g·ª≠i ·∫£nh
                      }
                    } else {
                      const errorData = await imageResponse.json();
                      console.error("Error generating image:", errorData.error);
                      
                      // G·ª≠i th√¥ng b√°o l·ªói n·∫øu kh√¥ng t·∫°o ƒë∆∞·ª£c ·∫£nh
                      const errorChunk = `data: ${JSON.stringify({ 
                        text: `R·∫•t ti·∫øc, t√¥i kh√¥ng th·ªÉ t·∫°o ·∫£nh theo y√™u c·∫ßu c·ªßa b·∫°n. ${errorData.error || ""}

`
                      })}

`;
                      controller.enqueue(encoder.encode(errorChunk));
                    }
                  } catch (error) {
                    console.error("Exception when generating image:", error);
                    
                    // G·ª≠i th√¥ng b√°o l·ªói n·∫øu c√≥ ngo·∫°i l·ªá
                    const errorChunk = `data: ${JSON.stringify({ 
                      text: `R·∫•t ti·∫øc, ƒë√£ x·∫£y ra l·ªói khi t·∫°o ·∫£nh. Vui l√≤ng th·ª≠ l·∫°i sau.

`
                    })}

`;
                    controller.enqueue(encoder.encode(errorChunk));
                  }
                }
              }
              
              // X·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ m√¥ h√¨nh n·∫øu kh√¥ng ph·∫£i l√† y√™u c·∫ßu t·∫°o ·∫£nh ho·∫∑c sau khi ƒë√£ x·ª≠ l√Ω l·ªói t·∫°o ·∫£nh
              if (!shouldGenerateImage || (imageGenerationNotification && !translatedPrompt)) {
                try {
                  let accumulatedText = "";
                  
                  // X·ª≠ l√Ω t·ª´ng chunk t·ª´ stream ƒë·ªÉ t·ªëi ƒëa h√≥a s·ªë l∆∞·ª£ng token
                  for await (const chunk of response) {
                    if (chunk.choices && chunk.choices[0]?.delta?.content) {
                      const content = chunk.choices[0].delta.content;
                      accumulatedText += content;
                      
                      // G·ª≠i ph·∫£n h·ªìi theo t·ª´ng ƒëo·∫°n ƒë·ªÉ hi·ªÉn th·ªã ngay l·∫≠p t·ª©c
                      const dataChunk = `data: ${JSON.stringify({ text: content })}\n\n`;
                      controller.enqueue(encoder.encode(dataChunk));
                    }
                  }
                  
                  console.log(`Total response length: ${accumulatedText.length} characters`);
                  
                  // K·∫øt th√∫c stream
                  controller.enqueue(encoder.encode('data: [DONE]\n\n'));
                  controller.close();
                } catch (error) {
                  console.error('Error processing model response:', error);
                  controller.error(error);
                }
              }
            } catch (error) {
              console.error('Error in stream processing:', error);
              controller.error(error);
            }
          }
        }),
        {
          headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive'
          }
        }
      )
    } catch (error) {
      console.error("Error creating chat completion:", error)

      // Ph√¢n t√≠ch l·ªói ƒë·ªÉ cung c·∫•p th√¥ng b√°o l·ªói c·ª• th·ªÉ
      let errorMessage = "ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu. Vui l√≤ng th·ª≠ l·∫°i sau."
      let statusCode = 500

      if (error instanceof Error) {
        if (error.message.includes("API key")) {
          errorMessage = "API key kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n."
          statusCode = 401
        } else if (error.message.includes("model")) {
          errorMessage = `M√¥ h√¨nh ${MODEL_CONFIG.modelId} kh√¥ng kh·∫£ d·ª•ng ho·∫∑c kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£.`
          statusCode = 400
        } else if (error.message.includes("rate limit")) {
          errorMessage = "ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n t·ªëc ƒë·ªô API. Vui l√≤ng th·ª≠ l·∫°i sau."
          statusCode = 429
        } else if (error.message.includes("timeout")) {
          errorMessage = "Y√™u c·∫ßu ƒë√£ h·∫øt th·ªùi gian ch·ªù. Vui l√≤ng th·ª≠ l·∫°i sau."
          statusCode = 504
        }
      }

      // Th·ª≠ ph∆∞∆°ng √°n d·ª± ph√≤ng - tr·∫£ v·ªÅ ph·∫£n h·ªìi kh√¥ng streaming
      try {
        console.log("Attempting fallback to non-streaming response")
        
        // Th·ª≠ v·ªõi c√°c m√¥ h√¨nh d·ª± ph√≤ng n·∫øu l·ªói li√™n quan ƒë·∫øn m√¥ h√¨nh
        let fallbackModelToUse = modelToUse;
        if (error instanceof Error && error.message.includes("model") && modelToUse === MODEL_CONFIG.modelId) {
          // Th·ª≠ v·ªõi m√¥ h√¨nh d·ª± ph√≤ng ƒë·∫ßu ti√™n
          if (MODEL_CONFIG.fallbackModels && MODEL_CONFIG.fallbackModels.length > 0) {
            fallbackModelToUse = MODEL_CONFIG.fallbackModels[0];
            console.log(`Trying fallback model: ${fallbackModelToUse}`);
          }
        }
        
        // Thi·∫øt l·∫≠p timeout cho y√™u c·∫ßu d·ª± ph√≤ng
        const abortController = new AbortController();
        const timeoutId = setTimeout(() => {
          abortController.abort();
        }, 30000); // 30 gi√¢y timeout cho ph∆∞∆°ng √°n d·ª± ph√≤ng
        
        const fallbackResponse = await groq.chat.completions.create({
          model: fallbackModelToUse,
          messages: [{ role: "system", content: systemPrompt }, ...messages],
          stream: false,
          temperature: MODEL_CONFIG.temperature,
          max_tokens: MODEL_CONFIG.maxTokens,
        }, { signal: abortController.signal });
        
        clearTimeout(timeoutId);
        
        if (fallbackResponse.choices && fallbackResponse.choices.length > 0) {
          const content = fallbackResponse.choices[0].message.content || "";
          console.log("Fallback response received successfully");
          
          return new Response(
            JSON.stringify({ 
              text: content,
              imageAttachment: imageGenerationResponse ? {
                id: uuidv4(),
                type: "image",
                url: imageGenerationResponse.imageUrl,
                name: `AI Image: ${imageGenerationResponse.prompt.substring(0, 30)}${imageGenerationResponse.prompt.length > 30 ? "..." : ""}`,
                prompt: imageGenerationResponse.prompt
              } : null
            }),
            { 
              status: 200, 
              headers: { "Content-Type": "application/json" } 
            }
          );
        } else {
          throw new Error("No content in fallback response");
        }
      } catch (fallbackError) {
        console.error("Fallback response failed:", fallbackError);
        
        // N·∫øu c·∫£ ph∆∞∆°ng √°n d·ª± ph√≤ng c≈©ng th·∫•t b·∫°i, tr·∫£ v·ªÅ l·ªói ban ƒë·∫ßu
        return new Response(
          JSON.stringify({ error: errorMessage }),
          { status: statusCode, headers: { "Content-Type": "application/json" } }
        );
      }
    }
  } catch (error) {
    console.error("Unhandled error in API route:", error);
    return new Response(
      JSON.stringify({ error: "ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh. Vui l√≤ng th·ª≠ l·∫°i sau." }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}

// Th√™m endpoint ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i API
export async function GET() {
  try {
    const connectionTest = await testGroqConnection()

    // Ki·ªÉm tra c√°c t·ªáp ki·∫øn th·ª©c
    let knowledgeStatus = {
      success: true,
      message: "C∆° s·ªü ki·∫øn th·ª©c ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng",
      error: null
    }
    
    try {
      // Th·ª≠ t√¨m ki·∫øm v·ªõi m·ªôt truy v·∫•n ƒë∆°n gi·∫£n ƒë·ªÉ ki·ªÉm tra c∆° s·ªü ki·∫øn th·ª©c
      await searchDocuments("test")
    } catch (error) {
      knowledgeStatus = {
        success: false,
        message: "Kh√¥ng th·ªÉ truy c·∫≠p c∆° s·ªü ki·∫øn th·ª©c",
        error: error instanceof Error ? error.message : "Unknown error"
      }
    }
    
    // Ki·ªÉm tra API t·∫°o ·∫£nh
    let imageApiStatus = {
      success: true,
      message: "API t·∫°o ·∫£nh ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng",
      error: null
    }
    
    try {
      // Ki·ªÉm tra API key c·ªßa TensorArt
      const tensorArtApiKey = process.env.TENSORART_API_KEY
      if (!tensorArtApiKey) {
        throw new Error("TENSORART_API_KEY kh√¥ng ƒë∆∞·ª£c c·∫•u h√¨nh")
      }
      
      // Kh√¥ng th·ª±c s·ª± g·ªçi API t·∫°o ·∫£nh v√¨ t·ªën t√†i nguy√™n, ch·ªâ ki·ªÉm tra API key
    } catch (error) {
      imageApiStatus = {
        success: false,
        message: "Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn API t·∫°o ·∫£nh",
        error: error instanceof Error ? error.message : "Unknown error"
      }
    }
    
    return new Response(
      JSON.stringify({
        timestamp: new Date().toISOString(),
        groq: connectionTest,
        knowledge: knowledgeStatus,
        imageApi: imageApiStatus,
        config: {
          modelId: MODEL_CONFIG.modelId,
          maxTokens: MODEL_CONFIG.maxTokens
        }
      }),
      { status: 200, headers: { "Content-Type": "application/json" } }
    )
  } catch (error) {
    return new Response(
      JSON.stringify({
        error: "Kh√¥ng th·ªÉ ki·ªÉm tra tr·∫°ng th√°i API",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    )
  }
}
